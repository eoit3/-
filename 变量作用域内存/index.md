## 原始值与引用值
---
**原始值**就是简单的数据。

**引用值**就是由多个值构成的对象。

### 复制值
- 原始值存储在栈中
- 引用值存储在堆内存中
- 引用值在复制时复制的是一个指针，指针指向存在堆内存中的对象。复制后仍然指针指向的仍然是堆内存中的对象。（可以利用深拷贝解决）

### 传递参数
- ECMA中的函数的参数都是按值传递的。
- ECMA中的函数的参数就是局部变量。

### 判断类型
- 利用typeof(无法准确判断引用类型)。
- 利用instanceof判断引用类型(检测原始值永远都是false)

### 执行上下文与作用域
- 全局上下文是最外层的上下文。（window对象）通过var声明的全局变量或者函数都会**成为window对象的属性和方法**。使用let和const的**不会定义在全局上下文中**。但作用域链的解析效果是**相同**的。
- 上下文在执行完毕后会自动销毁，包括定义在它上面的所有的函数或变量。（全局上下文在应用退出前才会被销毁，比如关闭网页，或者关闭浏览器）
- 每个函数都有自己的上下文，代码执行进入函数，会被推入上下文栈中，函数执行完后会弹出，将控制权返还给之前的上下文。（ecma程序的执行流就是通过上下文栈控制的）
- 上下文在执行的时候会创建变量对象的一个**作用域链**。作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的**最前端**。全局上下文的变量对象始终是作用域链的**最后一个**。
- 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。从作用域最前端逐级往后，直到找到标识符。
- 内部上下文可以通过作用域链访问任何外部上下文中的一切。任何上下文都不能到下一级上下文中去搜索。
